
#用法
(region)	只遍历元素
(region, state)	可以中止循环
(region, state, index)	还能拿到每个元素的索引编号

Parallel.ForEach(regionList, (region, state, index) =>
{
    Console.WriteLine($"处理第 {index} 个区域");

    if (index > 10)
        state.Break(); // 超过10个区域就提前退出
});


类名	特点	适用场景
ConcurrentQueue<T>	FIFO，线程安全	多线程写入、顺序消费
ConcurrentStack<T>	LIFO，线程安全	回溯/撤销等栈操作
ConcurrentBag<T>	无序线程安全	并发收集、不关心顺序
ConcurrentDictionary<K,V>	键值对，线程安全	并发访问工位数据等
BlockingCollection<T>	阻塞式，支持多消费者	实现生产者-消费者模型

✅ 1. ConcurrentQueue<T> （线程安全的队列 - FIFO）
用途：多线程中将结果“按顺序排队处理”。

常用方法：

Enqueue(item)：添加元素。

TryDequeue(out T result)：尝试出队。

典型场景：并行图像区域处理后，将所有 RegionResult 排进一个队列，供后续逐个展示或保存。

✅ 2. ConcurrentStack<T> （线程安全的栈 - LIFO）
用途：类似于 ConcurrentQueue，但按“后进先出”顺序处理。

常用方法：

Push(item)：压栈。

TryPop(out T result)：尝试弹栈。

典型场景：某些任务需先处理最后的区域，比如图像金字塔分层回溯。

✅ 3. ConcurrentBag<T> （无序线程安全集合）
用途：比 queue/stack 更自由，适用于并行收集结果但不关心顺序。

常用方法：

Add(item)

TryTake(out T result)

典型场景：并发处理图像区域，结果存入一个“袋子”，最后统计数量或找最大值时使用。

✅ 4. ConcurrentDictionary<TKey, TValue>（线程安全字典）
用途：按“键值对”存储数据，线程安全。

常用方法：

TryAdd(key, value)

TryGetValue(key, out value)

AddOrUpdate(key, addValue, updateFunc)

典型场景：

用 key 表示工位编号，value 是工位处理结果。

多线程同时处理多个工位，不会冲突。

✅ 5. BlockingCollection<T>（支持阻塞/等待的线程安全集合）
用途：基于 ConcurrentQueue/Bag/Stack 实现的生产者-消费者队列，支持阻塞等待。

常用方法：

Add(item)：生产者线程加入任务。

Take()：消费者线程阻塞直到有任务。

典型场景：

图像采集线程持续添加图像帧，处理线程等待并处理。

用于流水线处理模型。


✅ 示例：Parallel.ForEach + ConcurrentBag + Dictionary 组合
csharp
复制
编辑
ConcurrentBag<RegionContextResult> resultBag = new ConcurrentBag<RegionContextResult>();
ConcurrentDictionary<int, RegionContextResult> resultDict = new ConcurrentDictionary<int, RegionContextResult>();

Parallel.ForEach(regionList, (region, state, index) =>
{
    var result = ProcessRegion(region);

    // 不关心顺序就放 Bag
    resultBag.Add(result);

    // 按区域编号存放（不会冲突）
    resultDict.TryAdd((int)index, result);
});
